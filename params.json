{"name":"Litestore","tagline":"Litestore library, a key-value store based on SQLite.","body":"Litestore library\r\n=================\r\n\r\nAbout\r\n-----\r\n### What it is and isn't?\r\nLitestore library is a lightweight, embeddable, zero config, key-value style\r\nstorage system build on SQLite3 database (http://www.sqlite.org/).\r\n\r\nIt's not a full document database or key-value store server system.\r\nLIttle like comparing SQLite to Mysql or PotgreSQL (actually SQLite compares\r\nbetter than Litestore to Couch...).\r\n\r\nLitestore is quite low level. It can be used as is but is intended to be built\r\nupon. More about the design in section 'Implementation details'.\r\n\r\n### Why should I use it?\r\n* If you just want things to work and don't really care about SQL or playing\r\nwith files.\r\n* You want to save multiple values in a consistent transactional\r\nway that regular files just can't do.\r\n* Full blown document databases like, CouchDB, MongoDB or Redis are just too\r\nhuge and have too much dependencies.\r\n\r\nLicense\r\n-------\r\nMIT\r\nSee LICENSE.txt\r\n\r\nSQLite is released in the public domain,\r\nsee: http://www.sqlite.org/copyright.html\r\nThis library does not modify SQLite, only links against it.\r\n\r\nBuilding\r\n--------\r\nmake && sudo make install\r\n\r\n### Dependencies\r\nThe library:\r\n* C99 compiler (*compile*)\r\n\r\n    Should be adaptable to older standard.\r\n    \r\n   Tested with gcc (4.7.3 64bit, Linux)\r\n* Make or your own build system (*compile*)\r\n* SQLite3 library (*compile*, *runtime*)\r\n    \r\n   http://www.sqlite.org/\r\n\r\nFor tests:\r\n* C++ compiler\r\n* gtest\r\n\r\nVersioning\r\n----------\r\nSemantic versioning 2.0: http://semver.org/spec/v2.0.0.html\r\nSee file VERSION, for current version.\r\n\r\nUsage example\r\n-------------\r\n```c\r\n#include <string.h>\r\n#include <litestore/litestore.h>\r\n\r\n/* Callback for raw data, that allocates a new string */\r\nint alloc_str(litestore_blob_t value, void* user_data)\r\n{\r\n    char** res = (char**)user_data;\r\n    *res = strndup((const char*)value.data, value.size)\r\n}\r\n\r\nint main(const int argc, const char** argv)\r\n{\r\n    if (argc > 2)\r\n    {\r\n\t    printf(\"Must provide DB file name!\\n\");\r\n        return 0;\r\n    }\r\n    \r\n    /* Open the connection */\r\n    litestore* ls = NULL;\r\n    if (litestore_open(argv[1], &ls) != LITESTORE_OK)\r\n\t{\r\n\t\tlitestore_close(ls);\r\n\t    printf(\"ERROR!\\n\");\r\n\t\treturn -1;\r\n    }\r\n\r\n    /* Save raw data */\r\n    const char* key = \"Hello\";\r\n\tconst char* value = \"World!\";\r\n    if (litestore_save_raw(ls,\r\n                           litestore_slice_str(key),\r\n                           litestore_make_blob(value, strlen(value))\r\n        != LITESTORE_OK))\r\n    {\r\n        litestore_close(ls);\r\n   \t    printf(\"ERROR!\\n\");\r\n        return -1;\r\n    }\r\n\r\n    /* Read the saved data, note callback usage */\r\n\tchar* res = NULL;\r\n\tif (litestore_get_raw(ls,\r\n                          litestore_slice_str(key),\r\n                          &alloc_str, &res)\r\n        == LITESTORE_OK)\r\n    {\r\n        printf(\"%s %s\\n\", key, res);\r\n        free(res);\r\n    }\r\n\r\n    /* Clean up, close the connection */\r\n\tlitestore_close(ls);\r\n    return 0;\r\n}\r\n```\r\n\r\nBasics\r\n------\r\nLitestore can save **objects**. Each **object** has a **key** and a **value**.\r\nThe value can have different types. The key is a user defined **UTF-8 encoded**\r\nstring. It can have arbitrary length, though this naturally affects performance\r\nsince objects are accessed based on the key.\r\n\r\n### Object values\r\n#### Value types\r\nLitestore can save four (4) different types of objects. These are:\r\n* null\r\n* raw\r\n* array\r\n* key-value\r\n\r\n##### Null\r\nSimplest is the **null** type. Basically it can be used as **boolean** type\r\nthat either exists or it doesn't. It has no real value and only the key is\r\nstored.\r\n\r\n##### Raw\r\nThe **raw** type is just a binary **blob** and is saved as is.\r\nIt can be used for any user defined type that can be saved as bytes,\r\neither directly or by serializing. Format is totally user dependent.\r\n\r\n##### Array\r\n**Arrays** are actually **arrays of blobs**. They retain the order of objects.\r\nI.E. when an array is read, the objects will be in the same order as they\r\napeared in the original array that was saved.\r\n\r\nThe array indexes, objects, are blobs and hence have the same propertied as\r\nraw data.\r\n\r\n##### Key-value\r\n**Key-value** object is basically a heterogenus **blob-blob map**, where both\r\nthe map-key and the map-value are user defined data. One thing to note is that\r\nthe map-key is a blob and equality is compared as byte data\r\n(SQLite [implementation](http://www.sqlite.org/datatype3.html)).\r\n\r\nImplementation details\r\n----------------------\r\nTODO\r\n\r\n### Design goals\r\n#### Consistency\r\nThe API aims to be concise. All functions return values indicate the success \r\nstatus of the function and possible output parameters are given as the right \r\nmost function parameters. All API functions and types are prefixed with \r\n**litestore_**. The implementation is not leaked to the user.\r\n\r\n#### Minimum memory allocations\r\nThe only memory Litestore library itself allocates, is during open, for the\r\n**litestore** context object. The underlying implementation (*SQLite3*) does \r\nallocations on it's own and these can't be avoided. How ever all the data is \r\npassed as directly as possible and possible allocations are left for the \r\nuser. This enables the usage of custom allocators.\r\n\r\nThis is also the reasoning behind the callback style API, that admittedly is\r\nmore cumbersome to use.\r\n\r\nOn some systems the length of a string is know after constuction \r\n(C++ for instance). This is the reason for using the **slice_t** type for\r\nstrings. SQLite needs to know the length of the string (or blob) and if it is \r\nmore efficient if explicit **strlen()** calls can be avoided.\r\n\r\n### Transactions\r\nLitestore can be used with **explicit** transactions or **implicit** \r\ntransactions. Explicit transactions mean that the user calls the **_tx** \r\nfunctions explicitely and creates an explicit transaction scope.\r\n\r\nIf no explicit transaction is created, one will be created on each API call.\r\nAnd commited if the call succeeds.\r\n\r\nFor better **performance**, always use **explicit** transactions to group\r\nAPI calls.\r\n\r\n### Thread safety\r\nThe API is **not** thread safe. I.E. using the same connection/context in \r\nmultiple threads is not safe. How ever all the state is stored in the context \r\nso it should be safe to create multiple connections, one for each thread, \r\nto the same DB. \r\nSQLite it self is thread safe, if configured properly.\r\nSee: http://www.sqlite.org/threadsafe.html\r\n\r\nDonate\r\n------\r\n\r\n### PayPal\r\n\r\n<div>\r\n<form action=\"https://www.paypal.com/cgi-bin/webscr\" method=\"post\" target=\"_top\">\r\n<input type=\"hidden\" name=\"cmd\" value=\"_s-xclick\">\r\n<input type=\"hidden\" name=\"encrypted\" value=\"-----BEGIN PKCS7-----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-----END PKCS7-----\r\n\">\r\n<input type=\"image\" src=\"https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif\" border=\"0\" name=\"submit\" alt=\"PayPal - The safer, easier way to pay online!\">\r\n<img alt=\"\" border=\"0\" src=\"https://www.paypalobjects.com/en_US/i/scr/pixel.gif\" width=\"1\" height=\"1\">\r\n</form>\r\n</div>\r\n\r\n### Bitcoin\r\n17LEp96XCiTQwTrFWnaQ7jzJC1YjK5pJci\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}